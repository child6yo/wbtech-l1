package main

// Реализовать паттерн проектирования «Адаптер» на любом примере.
// Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.
// Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой,
// несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.
// Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.

// клиентский интерфейс кеша
type cache interface {
	put(data int) error
	get(id int) error
}

// клиентская реализация кеша
type lruCache struct{}

func (lru *lruCache) put(data int) error {
	return nil
}

func (lru *lruCache) get(id int) error {
	return nil
}

// сторонняя реализация кеша
type lfuCache struct{}

func (lfu *lfuCache) putOne(data int) error {
	return nil
}

func (lfu *lfuCache) getByID(id int) error {
	return nil
}

// адаптация сторонней реализации под клиентский интерфейс
type lfuCacheAdapter struct {
	lfuCache *lfuCache
}

func (a *lfuCacheAdapter) put(data int) error {
	return a.lfuCache.putOne(data)
}

func (a *lfuCacheAdapter) get(id int) error {
	return a.lfuCache.getByID(id)
}

// таким образом, паттер в основном применим к случаям, где необходимо
// адаптировать сторонние объекты под собственный интерфейс или наоборот
// также адаптером можно расширять функциональность глобального интерфейса в местах, где это необходимо

// на практике лучше всего применим при работе над совместимостью с изначально несовместимыми библиотеками,
// например, если библиотека работает с json, а нам нужно обрабатывать xml - можешь помочь адаптер

// плюсы: упрощает интеграцию сторонних библиотек, делает код более гибким
// минусы: усложняет код

func main() {

}
